
open import Level using (_⊔_) renaming (suc to lsuc)
open import Data.Bool using (Bool; true; false; if_then_else_; not; _∧_; _∨_)
open import Data.Nat using (ℕ; suc; zero; _*_; _≤?_)
open import Data.Fin using (Fin; fromℕ≤; toℕ) renaming (suc to fsuc ; zero to fzero; _<_ to _<ₙ_; _≤_ to _≤ₙ_)
open import Data.Fin.Properties using (toℕ-fromℕ≤) renaming (_≟_ to _≟[Fin]_)
open import Data.List using (List; []; _∷_; zip; replicate; map; concat) renaming (foldr to foldrₗ; _++_ to _++ₗ_)
open import Data.List.Any as Any using (here; there)
open import Data.List.All using (All; _∷_; []) renaming (map to mapₐ)
open import Data.List.All using () renaming (_∷_ to test)
open import Data.List.All.Properties using (gmap)
open import Data.Product using (∃; ∃₂; _×_; proj₁; proj₂; _,_)
open import Data.Maybe using (just; nothing)
open import Data.Vec using (Vec; allFin) renaming (toList to toListᵥ; _∈_ to _∈ᵥ_)
open import Data.Vec.Properties using (∈-allFin)
open import Relation.Nullary using (¬_; yes; no)
open import Relation.Nullary.Decidable using (⌊_⌋)
open import Relation.Binary
open import Relation.Binary.PropositionalEquality using (_≡_; _≢_; cong; inspect; subst₂; subst; [_]) renaming (refl to ≡-refl; sym to ≡-sym; trans to ≡-trans; setoid to ≡-setoid)
open import Relation.Binary.List.Pointwise using () renaming (setoid to list-setoid)
open import Algebra.FunctionProperties using (Op₂)
open import Relation.Nullary.Negation using (contradiction)
open import Relation.Binary.Consequences using (Total)
open import Function using (_∘_)

open import RoutingLib.Data.Graph using () renaming (Graph to Graph'; nodes to nodes')
open import RoutingLib.Data.Graph.EPath using () renaming (EPath to EPath'; [_] to [_]′)
open import RoutingLib.Data.List.All using (AllPairs; []; _∷_)
open import RoutingLib.Data.List.All.Properties using (forced-map; concat-all; map-pairs; ∈-all)
open import RoutingLib.PigeonHole using (tooFewPigeons)
open import RoutingLib.Data.List.Any.GenericMembership using (Disjoint; disjoint-[]; toList-preserves-∈; concat-∈)  
open import RoutingLib.Data.List.Any.DoubleGenericMembership using (map-∈)
open import RoutingLib.Data.Fin.Properties using (toℕ-injective₂)
open import RoutingLib.Data.Nat.Properties using (m≰n⇨n<m)
open import RoutingLib.Data.List.Enumeration using (Enumerable; Enumeration)

open import RoutingLib.Data.Graph.EPath
open import RoutingLib.Data.Graph.EPath.Properties
open import RoutingLib.Data.List.Any.Uniqueness using (Unique)
open import RoutingLib.Data.List.Any.Uniqueness.Properties using (concat!; allFin!; map!)

module RoutingLib.Data.Graph.EPath.Enumeration {n : ℕ} where


  open Any.Membership (≡-setoid ℕ) using () renaming (_∈_ to _∈ℕ_)
  open Any.Membership (≈ₚ-setoid n) using () renaming (_∈_ to _∈ₚ_)
  open Setoid (list-setoid (≈ₚ-setoid n)) using () renaming (reflexive to ≈ₗₚ-reflexive)  
  
  
  Fₛ : Setoid _ _
  Fₛ = ≡-setoid (Fin n)

  ℕₛ : Setoid _ _
  ℕₛ = ≡-setoid ℕ

  Pₛ : Setoid _ _
  Pₛ = ≈ₚ-setoid n

  nodes : Vec (Fin n) n
  nodes = allFin n




  -- extensions

  extend : List (EPath n) → Fin n → List (EPath n)
  extend [] i = []
  extend (p ∷ ps) i with i ∉? p
  ... | no _    = extend ps i
  ... | yes i∉p = (i ∷ p ∣ i∉p) ∷ extend ps i

  extend-completeness : ∀ {i q i∉q ps} → q ∈ₚ ps → i ∷ q ∣ i∉q ∈ₚ extend ps i
  extend-completeness {i} {i∉q = i∉q} {p ∷ ps} (here q≈p) with i ∉? p
  ... | no i∈p = contradiction (∉-resp-≈ₚ q≈p i∉q) i∈p
  ... | yes _  = here (≡-refl ∷ q≈p)
  extend-completeness {i} {ps = p ∷ ps} (there q∈ps) with i ∉? p
  ... | no  _ = extend-completeness q∈ps
  ... | yes _ = there (extend-completeness q∈ps)

  extend-∈ : ∀ {i v} ps → v ∈ₚ extend ps i → ∃₂ λ q i∉q → (v ≈ₚ i ∷ q ∣ i∉q) × (q ∈ₚ ps)
  extend-∈ []  ()
  extend-∈ {i} (p ∷ ps) v∈ext with i ∉? p
  ... | no _  with extend-∈ v∈ext
  ...   |= {!!}
  ... | yes i∉p with v∈ext
  ...   | here v≈p = p , i∉p , v≈p , here ≈ₚ-refl
  ...   | there _ = {!!}

  extend-≉ : ∀ {i v i∉p ps} → All (v ≉ₚ_) ps → All (i ∷ v ∣ i∉p ≉ₚ_) (extend ps i)
  extend-≉ [] = []
  extend-≉ {i} {ps = p ∷ _} (v≉p ∷ v≉ps) with i ∉? p
  ... | no  _ = extend-≉ v≉ps
  ... | yes _ = (λ {(_ ∷ v≈p) → v≉p v≈p}) ∷ extend-≉ v≉ps

  extend! : ∀ {ps} → Unique Pₛ ps → ∀ i → Unique Pₛ (extend ps i)
  extend!       [] _ = []
  extend! {ps = p ∷ ps} (p∉ps ∷ ps!) i with i ∉? p
  ... | no  _ = extend! ps! i
  ... | yes _ = extend-≉ p∉ps ∷ extend! ps! i

  extend-length : ∀ {l ps} → All (λ p → length p ≡ l) ps → (i : Fin n) → All (λ p → length p ≡ suc l) (extend ps i)
  extend-length [] _ = []
  extend-length {ps = p ∷ ps} (|p|≡l ∷ |ps|≡l) i with i ∉? p
  ... | no i∈p = extend-length |ps|≡l i
  ... | yes _  = cong suc |p|≡l ∷ extend-length |ps|≡l i

  extend-disjoint : ∀ {i j} ps qs → i ≢ j → Disjoint Pₛ (extend ps i) (extend qs j)
  extend-disjoint ps qs i≢j (v∈extᵢps , v∈extⱼqs) with extend-∈ ps v∈extᵢps | extend-∈ qs v∈extⱼqs
  ... | _ , _ , v≈i∷p , _ | _ , _ , v≈j∷q , _ = (p₀≢q₀⇨p≉q i≢j) (≈ₚ-trans (≈ₚ-sym v≈i∷p) v≈j∷q)


  -- All paths of length l 

  allPathsOfLength : ℕ → List (EPath n)
  allPathsOfLength zero = map [_] (toListᵥ nodes)
  allPathsOfLength (suc l) = concat (map (extend (allPathsOfLength l)) (toListᵥ nodes))

  allPathsOfLength-completeness : ∀ p → p ∈ₚ (allPathsOfLength (length p))
  allPathsOfLength-completeness [ i ]         = map-∈ Fₛ Pₛ [_] (toList-preserves-∈ Fₛ (∈-allFin i))
  allPathsOfLength-completeness (i ∷ p ∣ _) = concat-∈ Pₛ (extend-completeness (allPathsOfLength-completeness p)) (map-∈ Fₛ (list-setoid Pₛ) (≈ₗₚ-reflexive ∘ (cong (extend (allPathsOfLength (length p))))) (toList-preserves-∈ Fₛ (∈-allFin i)))

  allPathsOfLength! : ∀ l → Unique Pₛ (allPathsOfLength l)
  allPathsOfLength! zero    = map! Fₛ Pₛ p₀≢q₀⇨p≉q (allFin! Pₛ n)
  allPathsOfLength! (suc l) = concat! Pₛ (forced-map (extend! (allPathsOfLength! l)) (toListᵥ nodes)) (map-pairs Fₛ (allFin! Fₛ n) (extend-disjoint (allPathsOfLength l) (allPathsOfLength l)))

  allPathsOfLength-length : ∀ l → All (λ p → length p ≡ l) (allPathsOfLength l)
  allPathsOfLength-length zero    = forced-map (λ _ → ≡-refl) (toListᵥ nodes)
  allPathsOfLength-length (suc l) = concat-all (forced-map (extend-length (allPathsOfLength-length l)) (toListᵥ nodes))

  allPathsOfLength-disjoint : ∀ {l k} → l ≢ k → Disjoint Pₛ (allPathsOfLength l) (allPathsOfLength k)
  allPathsOfLength-disjoint {l} {k} l≢k (v∈pₗ , v∈pₖ) = l≢k (≡-trans (≡-sym (∈-all Pₛ {!!} (allPathsOfLength-length l) v∈pₗ)) (∈-all Pₛ {!!} (allPathsOfLength-length k) v∈pₖ))


  -- All paths

  allPaths : List (EPath n)
  allPaths = concat (map allPathsOfLength (map toℕ (toListᵥ nodes))) 
  
  allPaths-completeness : ∀ p → p ∈ₚ allPaths
  allPaths-completeness p with suc (length p) ≤? n
  ... | yes |p|≤n-1 = concat-∈ Pₛ (allPathsOfLength-completeness p) (map-∈ ℕₛ (list-setoid Pₛ) (≈ₗₚ-reflexive ∘ (cong allPathsOfLength)) (subst (λ v → v ∈ℕ map toℕ (toListᵥ nodes)) (toℕ-fromℕ≤ |p|≤n-1) (map-∈ Fₛ ℕₛ (cong toℕ) (toList-preserves-∈ Fₛ (∈-allFin (fromℕ≤ |p|≤n-1))))))
  ... | no  |p|≰n-1 with tooFewPigeons (m≰n⇨n<m |p|≰n-1) (toVec p) 
  ...   | i , j , i≢j , p[i]≡p[j] = contradiction (subst₂ (λ v w → v ≡ w) (lookup-toVec p i) (lookup-toVec p j) p[i]≡p[j]) (lookup! p i≢j)

  allPaths! : Unique Pₛ allPaths
  allPaths! = concat! Pₛ (forced-map allPathsOfLength! (map toℕ (toListᵥ nodes))) (map-pairs ℕₛ (map! Fₛ ℕₛ toℕ-injective₂ (allFin! Pₛ n)) allPathsOfLength-disjoint)


  isEnumeration : Enumeration Pₛ allPaths
  isEnumeration = record { 
      unique = allPaths!; 
      complete = allPaths-completeness
    }

  pathsEnumerable : Enumerable Pₛ
  pathsEnumerable = record { 
      list = allPaths; 
      enumeration = isEnumeration
    }
