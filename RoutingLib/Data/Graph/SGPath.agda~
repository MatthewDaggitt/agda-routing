open import Level using () renaming (zero to lzero)
open import Data.Fin using (Fin) renaming (zero to fzero; suc to fsuc)
open import Data.Fin.Properties using (_≟_)
open import Data.Nat using (ℕ; zero; suc)
open import Data.List using (List; []; _∷_; map)
open import Relation.Nullary using (¬_; yes; no)
open import Relation.Binary using (Decidable; Rel)
open import Relation.Binary.PropositionalEquality using (_≡_; _≢_)

open import RoutingLib.Data.Graph

module RoutingLib.Data.Graph.SGPath {a n} {A : Set a} where

  ---------------------
  -- Non-empty paths --
  ---------------------

  infix 4 _∉ₙₑ_ --_≈ₙₑ_ _≉ₙₑ_

  data NonEmptySGPath (n : ℕ) : Set lzero
  data _∉ₙₑ_ {n : ℕ} : Fin n → NonEmptySGPath n → Set lzero

  data NonEmptySGPath (n : ℕ) where
    _∺_∣_ : ∀ (i j : Fin n) → i ≢ j → NonEmptySGPath n
    _∷_∣_ : ∀ i p → i ∉ₙₑ p → NonEmptySGPath n

  data _∉ₙₑ_ {n : ℕ} where
    notThere : ∀ {i j k i≢j} → k ≢ i → k ≢ j → k ∉ₙₑ i ∺ j ∣ i≢j
    notHere  : ∀ {i p k i∉p} → k ≢ i → k ∉ₙₑ p → k ∉ₙₑ i ∷ p ∣ i∉p
{-
  _∉ₙₑ?_ : ∀ {n} → Decidable (_∉ₙₑ_ {n})
  k ∉ₙₑ? (i ∺ j ∣ _) with k ≟ i | k ≟ j 
  ... | yes k≡i | _       = no λ{(notThere k≢i _) → k≢i k≡i}
  ... | _       | yes k≡j = no λ{(notThere _ k≢j) → k≢j k≡j}
  ... | no  k≢i | no  k≢j = yes (notThere k≢i k≢j)
  k ∉ₙₑ? (i ∷ p ∣ _) with k ≟ i | k ∉ₙₑ? p
  ... | yes i≡j | _       = no λ{(notHere i≢j _) → i≢j i≡j }
  ... | _       | no  i∈p = no λ{(notHere _ i∉p) → i∈p i∉p}
  ... | no  i≢j | yes i∉p = yes (notHere i≢j i∉p)


  data _≈ₙₑₚ_ {n : ℕ} : Rel (NonEmptySPath n) lzero where
    _∺_ : ∀ {i j k l i≢j k≢l} → i ≡ j → k ≡ l → (i ∺ j ∣ i≢j) ≈ₙₑₚ (k ∺ l ∣ k≢l)
    _∷_ : ∀ {i j p q i∉p j∉q} → i ≡ j → p ≈ₙₑₚ q → (i ∷ p ∣ i∉p) ≈ₙₑₚ (j ∷ q ∣ j∉q)




  -- Full definition

  infix 4 _∉_
  data SPath (n : ℕ) : Set lzero where
    [] : SPath n
    [_] : NonEmptySPath n → SPath n

  data _∉_ {n : ℕ} : Fin n → SPath n → Set lzero where
    notHere : ∀ {i} → i ∉ []
    notThere : ∀ {i p} → i ∉ₙₑ p → i ∉ [ p ]

  _∈_ : ∀ {n} → Fin n → SPath n → Set lzero
  i ∈ p = ¬ (i ∉ p)

  _∉?_ : ∀ {n} → Decidable (_∉_ {n})
  k ∉? []    = yes notHere
  k ∉? [ p ] with k ∉ₙₑ? p
  ... | yes k∉p = yes (notThere k∉p)
  ... | no  k∈p = no λ{(notThere k∉p) → k∈p k∉p}



  -- Operations

  length : ∀ {n} → SPath n → ℕ
  length [] = 0
  length [ _ ∺ _ ∣ _ ] = 1
  length [ _ ∷ p ∣ _ ] = suc (length [ p ])
-}
{-
  source : ∀ {n} → SPath n → Fin n
  source [ i ] = i
  source (i ∷ _ ∣ _) = i

  destination : ∀ {n} → SPath n → Fin n
  destination [ i ] = i
  destination (_ ∷ p ∣ _) = destination p
-}

{-
  toList : ∀ {n} → SPath n → List (Fin n)
  toList [ i ]       = i ∷ []
  toList (i ∷ p ∣ _) = i ∷ toList p

  toVec : ∀ {n} → (p : EPath n) → Vec (Fin n) (suc (length p))
  toVec [ i ]        = i ∷ []
  toVec (i ∷ p ∣ _ ) = i ∷ toVec p
-}
{-  
  lookup : ∀ {n} → (p : EPath n) → Fin (suc (length p)) → (Fin n)
  lookup p fzero = source p
  lookup [ _ ] (fsuc ())
  lookup (i ∷ p ∣ _ ) (fsuc j) = lookup p j


-}

{-
  extendAll : ∀ {n} → List (NonEmptySPath n) → Fin n → List (NonEmptySPath n)
  extendAll []       _ = []
  extendAll (p ∷ ps) i with i ∉ₙₑ? p
  ... | no  _   = extendAll ps i
  ... | yes i∉p = i ∷ p ∣ i∉p ∷ extendAll ps i

  allPathsOfLength : ∀ {n} → ℕ → List (NonEmptySPath n)
  allPathsOfLength {n} zero = ? --map [_] (toListᵥ (allFin n))
  allPathsOfLength {n} (suc l) = ? --concat (map (extendAll (allPathsOfLength l)) (toListᵥ (allFin n)))

  allPaths : ∀ {n} → List (NonEmptySPath n)
  allPaths {n} = concat (map allPathsOfLength (map toℕ (toListᵥ (allFin n)))) 
-}

{-


  -- Equality over paths
 
  infix 4 _≈ₚ_ _≉ₚ_

  data _≈ₚ_ {n : ℕ} : Rel (EPath n) lzero where
    [_] : ∀ {i j} → i ≡ j → [ i ] ≈ₚ [ j ]
    _∷_ : ∀ {i j p q i∉p j∉q} → i ≡ j → p ≈ₚ q → i ∷ p ∣ i∉p ≈ₚ j ∷ q ∣ j∉q

  _≉ₚ_ : ∀ {n} → Rel (EPath n) lzero
  xs ≉ₚ ys = ¬ (xs ≈ₚ ys)



  -- Reverse lexicograph ordering over paths

  infix 4 _≤ₚ_ _≰ₚ_

  data _≤ₚ_ {n : ℕ} : Rel (EPath n) lzero where
    stop        : ∀ {i j} → i ≤ j → [ i ] ≤ₚ [ j ]
    stopLeft    : ∀ {i j q j∉q} → [ i ] ≤ₚ q → [ i ] ≤ₚ j ∷ q ∣ j∉q
    stopRight   : ∀ {i j p i∉p} → p ≉ₚ [ j ] → p ≤ₚ [ j ] → i ∷ p ∣ i∉p ≤ₚ [ j ]
    stepEqual   : ∀ {i j p q i∉p j∉q} → p ≈ₚ q → i ≤ j → i ∷ p ∣ i∉p ≤ₚ j ∷ q ∣ j∉q
    stepUnequal : ∀ {i j p q i∉p j∉q} → p ≉ₚ q → p ≤ₚ q  → i ∷ p ∣ i∉p ≤ₚ j ∷ q ∣ j∉q

  _≰ₚ_ : ∀ {n} → Rel (EPath n) lzero
  p ≰ₚ q = ¬ (p ≤ₚ q)


  -- Length ordering over pathsd

  infix 4 _≤ₗ_ _≰ₗ_
  
  _≤ₗ_ : ∀ {n} → Rel (EPath n) lzero
  p ≤ₗ q = length p ≤ℕ length q

  _≰ₗ_ : ∀ {n} → Rel (EPath n) lzero
  p ≰ₗ q = ¬ (p ≤ₗ q)

-}
