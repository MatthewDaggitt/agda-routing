open import Level using () renaming (zero to lzero)
open import Data.Nat using (ℕ; zero; suc; s≤s; _<_; _≤_; _∸_; _≟_; _⊔_; _+_)
open import Data.Nat.Properties using (1+n≰n; ≤-refl; ≤+≢⇒<; <⇒≤; +-suc; +-identityʳ)
open import Data.Fin using (Fin; toℕ)
open import Data.Fin.Properties using ()
open import Data.Fin.Subset using (Subset; _∈_; ⊤)
open import Data.Fin.Dec using (_∈?_)
open import Data.Fin.Subset.Properties using (∈⊤)
open import Data.List using (foldr; tabulate; applyDownFrom)
open import Data.Product using (∃; _×_; _,_; proj₁)
open import Relation.Binary.PropositionalEquality using (_≡_; _≢_; refl; sym; trans; subst; cong)
open import Relation.Nullary using (yes; no)
open import Relation.Nullary.Negation using (contradiction)
open import Induction.WellFounded using (Acc; acc)
open import Induction.Nat using () renaming (<-well-founded to <-wf)

open import RoutingLib.Asynchronous.Schedule using (Schedule; 𝕋)
open import RoutingLib.Data.Nat.Properties using (m<n≤o⇒o∸n<o∸m)
open import RoutingLib.Data.Table using (max)

module RoutingLib.Asynchronous.Schedule.Times {n}(𝕤 : Schedule n) where

    open Schedule 𝕤

    ∈-α-comm : ∀ t k i → i ∈ α (t + suc k) → i ∈ α (suc t + k)
    ∈-α-comm t k i p = subst (i ∈_) (cong α (+-suc t k)) p

    -----------------
    -- Activations --
    -----------------

    -- nextActive' returns t+k given that i is accessed at time t+k
    nextActive' : (t k : 𝕋)(i : Fin n) → i ∈ α (t + suc k)
                  → Acc _<_ k → ∃ λ x → i ∈ α x
    nextActive' t zero    i p  _       = suc t ,
                subst (i ∈_) (cong α (trans (+-suc t 0) (cong suc (+-identityʳ t)))) p
    nextActive' t (suc k) i p (acc rs) with i ∈? α t
    ... | yes i∈α = t , i∈α
    ... | no  i∉α = nextActive' (suc t) k i (∈-α-comm t (suc k) i p)
        (rs k ≤-refl)

    -- nextActive returns a time after t, t', such that i is accessed at t'
    nextActive : 𝕋 → Fin n → 𝕋
    nextActive t i with (nonstarvation t i)
    ... | (k , p) = proj₁ (nextActive' t k i p (<-wf k))


    ---------------
    -- Data flow --
    ---------------

    -- expiryᵢⱼ returns a time such that i only uses data from j after time t
    expiryᵢⱼ : 𝕋 → Fin n → Fin n → 𝕋
    expiryᵢⱼ t i j = max {suc t} 0 (λ x → (toℕ x) + proj₁ (finite (toℕ x) i j))

    -- expiryᵢ returns a time ≥ t such that i only ever uses data from after time t
    expiryᵢ : 𝕋 → Fin n → 𝕋
    expiryᵢ t i = max t (expiryᵢⱼ t i)

    -- expiry returns a time ≥ t such that all nodes only ever uses data from after time t
    expiry : 𝕋 → 𝕋
    expiry t = max t (expiryᵢ t)

    
    ---------------
    -- Pseudo-Cycles --
    ---------------
    
    -- Definition of φ
    φ : 𝕋 → 𝕋
    φ zero    = zero
    φ (suc t) = suc (expiry (max {n} (φ t) (nextActive (φ t))))
    
    -- Definition of τ
    τ : 𝕋 → Fin n → 𝕋
    τ zero    i = zero
    τ (suc t) i = nextActive (φ (suc t)) i

{-
    module ActivationTimes {α : 𝔸 n} (sf : StarvationFree α) where

      nextActivation' : ∀ {t t' i} → Acc _<_ (t' ∸ t) → t < t' → i ∈ α t' → ℕ
      nextActivation' {t} {t'} {i} (acc t'∸t-acc) t<t' i∈αₜ' with i ∈? α (suc t) | (suc t) ≟ t'
      ... | yes i∈αₜ₊₁ | _          = suc t
      ... | no  i∉αₜ₊₁ | yes t+1≡t' = contradiction (subst (λ t → i ∈ α t) (sym t+1≡t') i∈αₜ') i∉αₜ₊₁
      ... | no  i∉αₜ₊₁ | no  t+1≢t' = nextActivation' (t'∸t-acc (t' ∸ suc t) (m<n≤o⇒o∸n<o∸m ≤-refl t<t')) (≤+≢⇒< t<t' t+1≢t') i∈αₜ'

      -- Returns the next time processor i is active after time t
      nextActivation : 𝕋 → Fin n → 𝕋
      nextActivation t i with sf t i
      ... | (t' , t<t' , i∈αₜ') = nextActivation' (<-wf (t' ∸ t)) t<t' i∈αₜ'
    
      -- Returns the first time such that all processors have activated after time t
      nextTotalActivation : 𝕋 → 𝕋
      nextTotalActivation t = max (suc t) (tabulate (nextActivation t))

      -- Given that a processor has been active before, returns the most recent activation since time t
      previousActivation : ∀ {t p i} → p ≤ t → i ∈ α p → 𝕋
      previousActivation {t} {p} {i} _   _    with i ∈? α t | p ≟ t
      previousActivation {t} {_} {_} _   _    | yes _  | _       =  t
      previousActivation {t} {_} {_} _   _    | _      | yes refl = t
      previousActivation {_} {_} {i} p≤t i∈αₚ | no i∉αₜ | no p≢t with ≤+≢⇒< p≤t p≢t
      ... | s≤s p≤t₂ = previousActivation p≤t₂ i∈αₚ

    ---------------
    -- Data flow --
    ---------------

    module DataFlowTimes {β : 𝔹 n} (dyn : Dynamic β) where

      -- The first time such that data generated by j at time tᵍ is not used again by i before time t
      pointExpiryᵢⱼ≤t : 𝕋 → 𝕋 → Fin n → Fin n → 𝕋
      pointExpiryᵢⱼ≤t tᵍ zero     i j = tᵍ
      pointExpiryᵢⱼ≤t tᵍ (suc t) i j with β t i j ≟ tᵍ
      ... | yes _ = suc t
      ... | no  _ = pointExpiryᵢⱼ≤t tᵍ t i j

      -- The first time such that data generated by j at time tᵍ is not used again by i
      pointExpiryᵢⱼ : 𝕋 → Fin n → Fin n → 𝕋
      pointExpiryᵢⱼ tᵍ i j with dyn tᵍ i j
      ... | (tᶠ , tᶠ-exp) = pointExpiryᵢⱼ≤t tᵍ (suc tᶠ) i j

      -- The first time such that i only ever uses data generated by j after time t 
      expiryᵢⱼ : 𝕋 → Fin n → Fin n → 𝕋
      expiryᵢⱼ t i j = max t (applyDownFrom (λ t → pointExpiryᵢⱼ t i j) (suc t))

      -- The first time such that i only ever uses data generated after time t
      expiryᵢ : 𝕋 → Fin n → 𝕋
      expiryᵢ t i = max t (tabulate (expiryᵢⱼ t i))

      -- The first time such that all processors only ever use data generated after time t
      expiry : 𝕋 → 𝕋
      expiry t = max t (tabulate (expiryᵢ t))

-}
    --------------------
    -- Schedule times --
    --------------------
{-
    module ScheduleTimes (𝕤 : Schedule n) where
      
      open Schedule 𝕤
      open ActivationTimes nonstarvation
      open DataFlowTimes finite

      -- Time at which n complete "synchronous" iterations have occurred
      syncIter : ℕ → 𝕋
      syncIter zero    = zero
      syncIter (suc n) = nextTotalActivation (expiry (syncIter n))

      -- An abstract version of syncIter that can be used to increase performance
      abstract

        syncIter𝔸 : ℕ → 𝕋
        syncIter𝔸 = syncIter

        syncIter𝔸-equiv : syncIter𝔸 ≡ syncIter
        syncIter𝔸-equiv = refl



      -- pseudoperiodᵢ

      pseudoperiodᵢ : 𝕋 → Fin n → 𝕋
      pseudoperiodᵢ t i = nextActivation (expiryᵢ t i) i      

      -- pseudoperiod

      pseudoperiod : ℕ → 𝕋
      pseudoperiod zero = zero
      pseudoperiod (suc n) = foldr _⊔_ (suc (pseudoperiod n)) (tabulate (pseudoperiodᵢ (pseudoperiod n)))

      -- An abstract version of pseudoperiod that can be used to increase performance
      abstract

        pseudoperiod𝔸 : ℕ → 𝕋
        pseudoperiod𝔸 = pseudoperiod

        pseudoperiod𝔸-≡ : pseudoperiod𝔸 ≡ pseudoperiod
        pseudoperiod𝔸-≡ = refl

    open DataFlowTimes public
    open ActivationTimes public
    open ScheduleTimes public
-}
