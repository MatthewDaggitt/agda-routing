
open import Data.Nat using (suc; zero; _+_)
open import Data.List using (List)
open import Data.Fin using (Fin) renaming (zero to fzero; suc to fsuc)
open import Data.Fin.Properties using ()
open import Data.List.Any as Any using (satisfied)
open import Data.List.All using (All; []; _∷_; all) renaming (lookup to all-lookup)
open import Data.Vec using (Vec; allFin; lookup; toList)
open import Data.Vec.Properties using (lookup-allFin; ∈-allFin)
open import Data.Sum using (_⊎_; inj₁; inj₂)
open import Data.Product using (∃; ∃₂; _,_; _×_)
open import Relation.Binary using (_⇒_; Rel; Reflexive; Symmetric; Transitive; Decidable)
open import Relation.Nullary using (¬_; yes; no)
open import Relation.Nullary.Negation using (contradiction)
open import Relation.Binary.PropositionalEquality using (_≡_; _≢_; cong; subst) renaming (setoid to ≡-setoid; refl to ≡-refl; trans to ≡-trans; sym to ≡-sym)
open import Algebra.FunctionProperties using (RightIdentity; Commutative; Associative)

open import RoutingLib.Algebra.FunctionProperties
open import RoutingLib.Data.List.All.Properties using (¬All→Any¬)
open import RoutingLib.Data.Vec using (allPairs)
open import RoutingLib.Data.Vec.Properties using (lookup-map; ∈-allPairs)
open import RoutingLib.Relation.Binary.RespectedBy using (_RespectedBy_)

open import RoutingLib.Routing.Definitions

open import SimilarityConvergenceProof.SufficientConditions using (SufficientConditionsDBF)

module RoutingLib.Routing.Algorithms.DistributedBellmanFord.SimplifiedProperties 
  {a b ℓ n-1} 
  {rp : RoutingProblem a b ℓ n-1}
  (sc : SufficientConditionsDBF rp)
  where

  
  -----------
  -- Setup --
  -----------

  open RoutingProblem rp
  open SufficientConditionsDBF sc

  open import RoutingLib.Routing.Algorithms.DistributedBellmanFord rp
  open import RoutingLib.Data.Vec.SelectiveFolds ≈-setoid _⊕_ ⊕-pres-≈
  open Any.Membership (≡-setoid (Fin n × Fin n)) using (_∈_)
  open import RoutingLib.Data.List.Any.GenericMembership (≡-setoid (Fin n × Fin n)) using (toList-preserves-∈)

  -------------------------
  -- Source/destinations --
  -------------------------
  
  allNodes : Vec (Fin n) n
  allNodes = allFin n

  srcDstPairs : List (Fin n × Fin n)
  srcDstPairs = toList (allPairs allNodes allNodes)

  ∈-srcDstPairs : ∀ (p : Fin n × Fin n) → p ∈ srcDstPairs
  ∈-srcDstPairs (i , j) = toList-preserves-∈ (∈-allPairs allNodes allNodes (∈-allFin i) (∈-allFin j)) 


  abstract

    lookup-extensions : ∀ X i j k → lookup k (extensions X i j) ≡ A i k ▷ X k j
    lookup-extensions X i j k = ≡-trans (lookup-map k (allFin n)) (cong (λ v → A i v ▷ X v j) (lookup-allFin k))

    --------------
    -- Equality --
    --------------

    ≉-sym : Symmetric _≉_
    ≉-sym x≉y y≈x = x≉y (sym y≈x)

    -- Matrix equality
  
    ≈ₘ-reflexive : _≡_ ⇒ _≈ₘ_
    ≈ₘ-reflexive ≡-refl i j = reflexive ≡-refl

    ≈ₘ-refl : Reflexive _≈ₘ_
    ≈ₘ-refl i j = refl

    ≈ₘ-sym : Symmetric _≈ₘ_
    ≈ₘ-sym A≈B i j = sym (A≈B i j)

    ≈ₘ-trans : Transitive _≈ₘ_
    ≈ₘ-trans A≈B B≈C i j = trans (A≈B i j) (B≈C i j)
  

    -- Matrix inequality

    ≉ₘ-sym : Symmetric _≉ₘ_
    ≉ₘ-sym A≉B = λ B≈A → A≉B (λ i j → sym (B≈A i j))

    ≉ₘ-witness : ∀ {X Y} → X ≉ₘ Y → ∃₂ λ i j → ¬ (X i j ≈ Y i j)
    ≉ₘ-witness {X} {Y} X≉Y with (all (λ {(i , j) → X i j ≟ Y i j})) srcDstPairs
    ... | yes all  = contradiction (λ i j → all-lookup all (∈-srcDstPairs (i , j))) X≉Y
    ... | no  ¬all with satisfied (¬All→Any¬ (λ {(i , j) → X i j ≟ Y i j}) ¬all)
    ...   | (i , j) , y = i , j , y


    -----------------------
    -- Properties of A▷ₘ --
    -----------------------

    -- A▷ₘ is the extension of some route by going through some k
    AXᵢⱼ≈Aᵢₖ▷Xₖⱼ : Selective _≈_ _⊕_ → ∀ X i j → ∃ λ k → A▷ₘ X i j ≈ A i k ▷ X k j
    AXᵢⱼ≈Aᵢₖ▷Xₖⱼ ⊕-sel X i j with ∃-foldr ⊕-sel (extensions X i j)
    ... | k , s[exts]≈extsₖ = k , trans s[exts]≈extsₖ (reflexive (lookup-extensions X i j k))
  
    -- Under the following assumptions about ⊕, A▷ₘ always chooses the "best" option with respect to ⊕
    AXᵢⱼ≤Aᵢₖ▷Xₖⱼ : Selective _≈_ _⊕_ → Commutative _≈_ _⊕_ → Associative _≈_ _⊕_ → ∀ X i j l → (A i l ▷ X l j) ⊕ A▷ₘ X i j ≈ A▷ₘ X i j
    AXᵢⱼ≤Aᵢₖ▷Xₖⱼ ⊕-sel ⊕-comm ⊕-assoc X i j l = trans (⊕-pres-≈ (sym (reflexive (lookup-extensions X i j l))) refl) (foldr≤xs ⊕-sel ⊕-comm ⊕-assoc (extensions X i j) l)


    ---------------------
    -- Properties of σ --
    ---------------------

    -- Applying σ no times is equivalent to the identity function
    σ⁰X≡X : ∀ X → σ^ zero X ≡ X
    σ⁰X≡X _ = ≡-refl

    -- σ addition
    σᵐ⁺ⁿ≡σᵐσⁿ : ∀ m n X → σ^ (m + n) X ≡ σ^ m (σ^ n X)
    σᵐ⁺ⁿ≡σᵐσⁿ zero    _ _ = ≡-refl
    σᵐ⁺ⁿ≡σᵐσⁿ (suc m) n X = cong σ (σᵐ⁺ⁿ≡σᵐσⁿ m n X)

    -- After an iteration, the diagonal of the RMatrix is always the identity
    σXᵢᵢ≈Iᵢᵢ : Selective _≈_ _⊕_ → (∀ i s r → (s ▷ r) ⊕ I i i ≈ I i i) → ∀ X i → σ X i i ≈ I i i
    σXᵢᵢ≈Iᵢᵢ ⊕-sel Iᵢᵢ-almost-anᵣ-⊕ X i with AXᵢⱼ≈Aᵢₖ▷Xₖⱼ ⊕-sel X i i
    ... | k , A▷Xᵢᵢ≈Aᵢₖ▷Xₖⱼ = trans (⊕-pres-≈ A▷Xᵢᵢ≈Aᵢₖ▷Xₖⱼ refl) (Iᵢᵢ-almost-anᵣ-⊕ i (A i k) (X k i))

    -- After an iteration, the diagonals of any two RMatrices are equal
    σXᵢᵢ≈σYᵢᵢ : Selective _≈_ _⊕_ → (∀ i s r → (s ▷ r) ⊕ I i i ≈ I i i) → ∀ X Y i → σ X i i ≈ σ Y i i
    σXᵢᵢ≈σYᵢᵢ ⊕-sel Iᵢᵢ-almost-anᵣ-⊕ X Y i = trans (σXᵢᵢ≈Iᵢᵢ ⊕-sel Iᵢᵢ-almost-anᵣ-⊕ X i) (sym (σXᵢᵢ≈Iᵢᵢ ⊕-sel Iᵢᵢ-almost-anᵣ-⊕ Y i))

    -- σ either extends the route by going through some k or it chooses a trivial route from the identity matrix
    σXᵢⱼ≈Aᵢₖ▷Xₖⱼ⊎Iᵢⱼ : Selective _≈_ _⊕_ → ∀ X i j → (∃ λ k → σ X i j ≈ A i k ▷ X k j) ⊎ (σ X i j ≈ I i j)
    σXᵢⱼ≈Aᵢₖ▷Xₖⱼ⊎Iᵢⱼ ⊕-sel X i j with ⊕-sel (A▷ₘ X i j) (I i j)
    ... | inj₂ σXᵢⱼ≈Iᵢⱼ  = inj₂ σXᵢⱼ≈Iᵢⱼ
    ... | inj₁ σXᵢⱼ≈AXᵢⱼ with AXᵢⱼ≈Aᵢₖ▷Xₖⱼ ⊕-sel X i j
    ...   | k , AXᵢⱼ≈Aᵢₖ▷Xₖⱼ = inj₁ (k , trans σXᵢⱼ≈AXᵢⱼ AXᵢⱼ≈Aᵢₖ▷Xₖⱼ)

    -- Under the following assumptions about ⊕, σ always chooses the "best" option with respect to ⊕
    σXᵢⱼ≤Aᵢₖ▷Xₖⱼ : Selective _≈_ _⊕_ → Commutative _≈_ _⊕_ → Associative _≈_ _⊕_ → ∀ X i j k → (A i k ▷ X k j) ⊕ σ X i j ≈ σ X i j
    σXᵢⱼ≤Aᵢₖ▷Xₖⱼ ⊕-sel ⊕-comm ⊕-assoc X i j k = trans (sym (⊕-assoc (A i k ▷ X k j) (A▷ₘ X i j) (I i j))) (⊕-pres-≈ (AXᵢⱼ≤Aᵢₖ▷Xₖⱼ ⊕-sel ⊕-comm ⊕-assoc X i j k) refl)

  
