
open import Data.Nat using (ℕ; _*_)
open import Data.Vec using (Vec; _∷_; concat; map; _∈_; here; there)
open import Data.Product using (_×_; _,_; ∃₂)
open import Relation.Binary.PropositionalEquality using (_≡_; refl)

open import RoutingLib.Data.Vec.Properties

module RoutingLib.Data.Vec.Pairs where

  allPairs : ∀ {a} {A : Set a} -> {m n : ℕ} -> Vec A m -> Vec A n -> Vec (A × A) (m * n)
  allPairs xs ys = concat (map (λ x -> map (λ y -> (x , y)) ys) xs)

  allPairs-∈ : ∀ {a} {A : Set a} {m n : ℕ} (xs : Vec A m) (ys : Vec A n) {x y : A} → x ∈ xs → y ∈ ys → (x , y) ∈ allPairs xs ys
  allPairs-∈ (x ∷ xs) ys here         y∈ys = ∈-++ₗ (map-∈ (λ y → (x , y)) y∈ys)
  allPairs-∈ (x ∷ xs) ys (there x∈xs) y∈ys = ∈-++ᵣ (map (λ y → (x , y)) ys) (allPairs-∈ xs ys x∈xs y∈ys)

  allPairs-∃-∈ : ∀ {a} {A : Set a} {m n : ℕ} {xs : Vec A m} {ys : Vec A n} {v} → v ∈ allPairs xs ys → ∃₂ λ x y → v ≡ (x , y)
  allPairs-∃-∈ {v = (x , y)} xy∈allPairs = x , y , refl
