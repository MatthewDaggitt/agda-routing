open import Algebra.FunctionProperties using (Selective)
open import Data.List.Any using (here; there)
open import Data.List using (List; []; _‚à∑_; _++_; sum; map; foldr; concat)
open import Data.List.All using (All; []; _‚à∑_)
open import Data.Nat using (‚Ñï; zero; suc; _+_; _‚à∏_; _<_; _‚â§_; _‚â§?_; z‚â§n; s‚â§s; module ‚â§-Reasoning; ‚â§-pred)
open import Data.Nat.Properties using (_+-mono_; n‚à∏n‚â°0; +-‚à∏-assoc; ‚à∏-+-assoc; ‚â§-step; n‚â§m+n; m‚â§m+n; ‚â∞‚áí>; m+n‚à∏n‚â°m; m+n‚à∏m‚â°n; ‚à∏-mono)
open import Data.Nat.Properties.Simple using (+-suc; +-right-identity; +-assoc; +-comm)
open import Data.Fin using (Fin) renaming (zero to fzero; suc to fsuc)
open import Data.Fin.Properties using (_‚âü_)
open import Data.Product using (‚àÉ; ‚àÉ‚ÇÇ; _,_)
open import Relation.Binary using (tri<; tri‚âà; tri>)
open import Relation.Binary.PropositionalEquality using (_‚â°_; _‚â¢_; cong; subst; module ‚â°-Reasoning) renaming (refl to ‚â°-refl; sym to ‚â°-sym; trans to ‚â°-trans)
open import Relation.Nullary using (yes; no)
open import Relation.Nullary.Negation using (contradiction)
open import Function using (_‚àò_)

open import RoutingLib.Asynchronous using (Parallelisation)
open import RoutingLib.Asynchronous.Schedule
open import RoutingLib.Asynchronous.Schedule.Properties using (‚âàùîπ-appTrans)
open import RoutingLib.Data.Graph using (Graph)
open import RoutingLib.Data.Graph.SimplePath using (SimplePath; []; [_]; _‚à∑_‚à£_; _‚à∫_‚à£_; source; destination; edge-‚à∑)
open import RoutingLib.Data.Graph.SimplePath.NonEmpty using (SimplePath‚Åø·µó; length)
open import RoutingLib.Data.Nat.Properties using (‚â§-refl; ‚â§-trans; ‚â§-reflexive; _<?_; <-irrefl; cmp; m‚à∏n‚â°0‚áím‚â§n; m‚à∏n+n‚â°m; m‚â§n‚áím‚à∏n‚â°0; m+o‚â°n‚áím‚â°n‚à∏o; m<n‚áín‚à∏m‚â°1+o; <‚áí‚â§; ‚â∞‚áí‚â•; <‚áí‚â±; ‚âÆ‚áí‚â•; <‚áí‚â¢; +-mono·µ£-<; m+n‚âÆn; suc-injective; ‚â§-steps·µ£; m+o‚â§n‚áím‚â§n‚à∏o)
open import RoutingLib.Routing.Definitions using (RoutingAlgebra; RoutingProblem)
open import RoutingLib.Data.List using (tabulate)

module RoutingLib.Routing.Algorithms.BellmanFord.StateReconstruction.DataFlow
  {a b ‚Ñì n-1} (ra : RoutingAlgebra a b ‚Ñì)
  (‚äï-sel : Selective (RoutingAlgebra._‚âà_ ra) (RoutingAlgebra._‚äï_ ra))
  (G : Graph (RoutingAlgebra.Step ra) (suc n-1))
  where

  private

    n : ‚Ñï
    n = suc n-1

  abstract

    open import RoutingLib.Routing.Algorithms.BellmanFord.StateReconstruction.Core ra ‚äï-sel G

    open import RoutingLib.Routing.AlgebraicPaths.Consistent ra ‚äï-sel G
    open RoutingAlgebra ra using (refl)

    open Schedule
    open import RoutingLib.Routing.Algorithms.BellmanFord crp using (œÉ‚à•; I; Œ¥)
    open RoutingProblem crp using (RMatrix)
    open import RoutingLib.Asynchronous.Snapshot œÉ‚à• using (Snapshot; toList‚±º; _‚âà‚Çõ_; snapshot)
    open import RoutingLib.Data.List.Any.GenericMembership (C‚Çõ) using (_‚àà_)
    open Parallelisation œÉ‚à• using (_‚âà‚Çò_)

    ----------------------------------------------
    -- Useful operations on data flow functions --
    ----------------------------------------------

    -- resetùîπ prepends a given data flow function such that at time 1 every node accesses the original state at time 0
    resetùîπ : ùîπ n ‚Üí ùîπ n
    resetùîπ Œ≤ zero          i j = zero
    resetùîπ Œ≤ (suc zero)    i j = zero
    resetùîπ Œ≤ (suc (suc t)) i j = suc (Œ≤ (suc t) i j)
    
    resetùîπ-‚âàùîπ : ‚àÄ Œ≤ ‚Üí Œ≤ ‚ü¶ 0 ‚üß‚âàùîπ‚ü¶ 1 ‚üß resetùîπ Œ≤
    resetùîπ-‚âàùîπ Œ≤ zero i j                      = ‚â°-refl
    resetùîπ-‚âàùîπ Œ≤ (suc t) i j rewrite +-suc t 0 = ‚â°-refl

    resetùîπ-causal : ‚àÄ {Œ≤} ‚Üí Causal Œ≤ ‚Üí Causal (resetùîπ Œ≤)
    resetùîπ-causal causal zero i j    = s‚â§s z‚â§n
    resetùîπ-causal causal (suc t) i j = s‚â§s (causal t i j)

    resetùîπ-dynamic : ‚àÄ {Œ≤} ‚Üí Dynamic Œ≤ ‚Üí Dynamic (resetùîπ Œ≤)
    resetùîπ-dynamic {Œ≤} dyn zero    i j = 1 , Œª {(s‚â§s (s‚â§s z‚â§n)) ()}
    resetùîπ-dynamic {Œ≤} dyn (suc t) i j with dyn t i j
    ... | t·∂† , t·∂†-final = suc t·∂† , 1+t·∂†-final
      where
      1+t·∂†-final : ‚àÄ {t'} ‚Üí suc (suc t·∂†) ‚â§ t' ‚Üí resetùîπ Œ≤ t' i j ‚â¢ suc t
      1+t·∂†-final {zero}         ()
      1+t·∂†-final {suc zero}     (s‚â§s ())
      1+t·∂†-final {suc (suc t')} (s‚â§s 1+t·∂†‚â§1+t') = (t·∂†-final 1+t·∂†‚â§1+t') ‚àò suc-injective


    -- revPathùîπ generates a data flow function that will generate the required SimplePath in reverse
    revPathùîπ : SimplePath‚Åø·µó n ‚Üí ùîπ n
    revPathùîπ (_ ‚à∫ _ ‚à£ _) _       _ _ = zero
    revPathùîπ (_ ‚à∑ p ‚à£ _) (suc t) i j = revPathùîπ p t i j
    revPathùîπ (k ‚à∑ p ‚à£ _) zero    i j with i ‚âü k | j ‚âü source p
    ... | no  _ | _     = zero
    ... | _     | no  _ = zero
    ... | yes _ | yes _ = length p

    postulate test : ‚àÄ m n {o} ‚Üí n ‚à∏ m ‚â° suc o ‚Üí o ‚â° n ‚à∏ suc m
    
    revPathùîπ-causal : ‚àÄ p t i j ‚Üí revPathùîπ p (length p ‚à∏ t) i j ‚â§ t
    revPathùîπ-causal (_ ‚à∫ _ ‚à£ _) _ _ _ = z‚â§n
    revPathùîπ-causal (_ ‚à∑ p ‚à£ _) zero i j = revPathùîπ-causal p zero i j
    revPathùîπ-causal (k ‚à∑ p ‚à£ _) (suc t) i j with length p ‚â§? t
    revPathùîπ-causal (k ‚à∑ p ‚à£ _) (suc t) i j | yes |p|‚â§t rewrite m‚â§n‚áím‚à∏n‚â°0 |p|‚â§t with i ‚âü k | j ‚âü source p
    ... | no  _ | _     = z‚â§n
    ... | yes _ | no  _ = z‚â§n
    ... | yes _ | yes _ = ‚â§-step |p|‚â§t
    revPathùîπ-causal (k ‚à∑ p ‚à£ _) (suc t) i j | no  |p|‚â∞t with m<n‚áín‚à∏m‚â°1+o (‚â∞‚áí> |p|‚â∞t)
    ...   | o , |p|‚à∏t‚â°1+o rewrite |p|‚à∏t‚â°1+o | test t (length p) |p|‚à∏t‚â°1+o = revPathùîπ-causal p (suc t) i j

    revPathùîπ-dynamic : ‚àÄ p t i j ‚Üí revPathùîπ p t i j < length p
    revPathùîπ-dynamic (_ ‚à∫ _ ‚à£ _) _       _ _ = s‚â§s z‚â§n
    revPathùîπ-dynamic (_ ‚à∑ p ‚à£ _) (suc t) i j = ‚â§-step (revPathùîπ-dynamic p t i j)
    revPathùîπ-dynamic (k ‚à∑ p ‚à£ _) zero    i j with i ‚âü k | j ‚âü source p
    ... | no  _ | _     = s‚â§s z‚â§n
    ... | yes _ | no  _ = s‚â§s z‚â§n
    ... | yes _ | yes _ = ‚â§-refl


    -- pathùîπ prepends the provided data flow function with the sequence of steps necessary to generate the provided path
    pathùîπ : SimplePath‚Åø·µó n ‚Üí ùîπ n ‚Üí ùîπ n
    pathùîπ p Œ≤ t i j with t ‚â§? length p
    ... | yes _ = revPathùîπ p (suc (length p) ‚à∏ t) i j
    ... | no  _ = length p + Œ≤ (t ‚à∏ length p) i j

    pathùîπ-‚âàùîπ : ‚àÄ p Œ≤ ‚Üí Œ≤ ‚ü¶ 0 ‚üß‚âàùîπ‚ü¶ length p ‚üß pathùîπ p Œ≤
    pathùîπ-‚âàùîπ p Œ≤ t i j with suc (t + length p) ‚â§? length p
    ... | yes t+|p|<|p| = contradiction t+|p|<|p| (m+n‚âÆn t (length p))
    ... | no  t+|p|‚âÆ|p| = ‚â°-sym (
      begin
        length p + Œ≤ (suc t + length p ‚à∏ length p) i j ‚à∏ length p  ‚â°‚ü® cong (Œª t ‚Üí length p + Œ≤ t i j ‚à∏ length p) (m+n‚à∏n‚â°m (suc t) (length p)) ‚ü©
        length p + Œ≤ (suc t) i j ‚à∏ length p                        ‚â°‚ü® cong (_‚à∏ length p) (+-comm (length p) _) ‚ü©
        Œ≤ (suc t) i j + length p ‚à∏ length p                        ‚â°‚ü® m+n‚à∏n‚â°m (Œ≤ (suc t) i j) (length p) ‚ü©
        Œ≤ (suc t) i j                                              ‚â°‚ü® cong (Œª t ‚Üí Œ≤ t i j) (‚â°-sym (+-right-identity (suc t))) ‚ü©
        Œ≤ (suc t + 0) i j
      ‚àé)
      where open ‚â°-Reasoning

    pathùîπ-causal : ‚àÄ {Œ≤} ‚Üí Causal Œ≤ ‚Üí ‚àÄ p ‚Üí Causal (pathùîπ p Œ≤)
    pathùîπ-causal {Œ≤} causal p t i j with suc t ‚â§? length p
    ... | yes _     = s‚â§s (revPathùîπ-causal p t i j)
    ... | no  t‚âÆ|p| = 
      begin
        suc (length p) + Œ≤ (suc t ‚à∏ length p)   i j ‚â°‚ü® cong (suc (length p) +_) (cong (Œª t ‚Üí Œ≤ t i j) (+-‚à∏-assoc 1 (‚âÆ‚áí‚â• t‚âÆ|p|))) ‚ü©
        suc (length p) + Œ≤ (suc (t ‚à∏ length p)) i j ‚â§‚ü® +-mono·µ£-< (‚â§-refl {length p}) (causal (t ‚à∏ length p) i j) ‚ü©
        length p + (suc (t ‚à∏ length p))             ‚â°‚ü® cong (length p +_) (‚â°-sym (+-‚à∏-assoc 1 (‚âÆ‚áí‚â• t‚âÆ|p|))) ‚ü©
        length p + (suc t ‚à∏ length p)               ‚â°‚ü® m+n‚à∏m‚â°n (‚â∞‚áí‚â• t‚âÆ|p|) ‚ü©
        suc t
      ‚àé
      where open ‚â§-Reasoning

    pathùîπ-dynamic : ‚àÄ {Œ≤} ‚Üí Dynamic Œ≤ ‚Üí ‚àÄ p ‚Üí Dynamic (pathùîπ p Œ≤)
    pathùîπ-dynamic {Œ≤} dyn p t i j with suc t ‚â§? length p
    ... | yes t<|p| = length p , |p|-final
      where
      |p|-final : ‚àÄ {t'} ‚Üí length p < t' ‚Üí pathùîπ p Œ≤ t' i j ‚â¢ t
      |p|-final {t'} |p|<t' with t' ‚â§? length p
      ... | yes t'‚â§|p| = contradiction t'‚â§|p| (<‚áí‚â± |p|<t')
      ... | no  _      = (<‚áí‚â¢ (‚â§-steps·µ£ (Œ≤ (t' ‚à∏ length p) i j) t<|p|)) ‚àò ‚â°-sym
    ... | no  t‚âÆ|p| with dyn (t ‚à∏ length p) i j
    ...   | t·∂† , t·∂†-final = length p + t·∂† , |p|+t·∂†-final
      where
      |p|+t·∂†-final : ‚àÄ {t'} ‚Üí length p + t·∂† < t' ‚Üí pathùîπ p Œ≤ t' i j ‚â¢ t
      |p|+t·∂†-final {t'} |p|+t·∂†<t' |p|+Œ≤‚â°t with t' ‚â§? length p
      ... | yes _ = <‚áí‚â¢ (‚â§-trans (revPathùîπ-dynamic p (suc (length p) ‚à∏ t') i j) (‚âÆ‚áí‚â• t‚âÆ|p|)) |p|+Œ≤‚â°t
      ... | no  _ = t·∂†-final (m+o‚â§n‚áím‚â§n‚à∏o (‚â§-trans (‚â§-reflexive (cong suc (+-comm t·∂† (length p)))) |p|+t·∂†<t')) (m+o‚â°n‚áím‚â°n‚à∏o (‚â°-trans (+-comm _ (length p)) |p|+Œ≤‚â°t))


    -- path&resetùîπ prepends Œ≤ with the sequence of flows needed to generate the CRoute provided and then reset the state
    path&resetùîπ : SimplePath‚Åø·µó n ‚Üí ùîπ n ‚Üí ùîπ n
    path&resetùîπ p Œ≤ = resetùîπ (pathùîπ p Œ≤)

    path&resetùîπ-‚âàùîπ : ‚àÄ p Œ≤ ‚Üí Œ≤ ‚ü¶ 0 ‚üß‚âàùîπ‚ü¶ 1 + length p ‚üß path&resetùîπ p Œ≤ 
    path&resetùîπ-‚âàùîπ p Œ≤ = ‚âàùîπ-appTrans resetùîπ (pathùîπ p) 1 (length p) resetùîπ-‚âàùîπ (pathùîπ-‚âàùîπ p) Œ≤

    path&resetùîπ-causal : ‚àÄ p {Œ≤} ‚Üí Causal Œ≤ ‚Üí Causal (path&resetùîπ p Œ≤)
    path&resetùîπ-causal p causal t i j = resetùîπ-causal (pathùîπ-causal causal p) t i j



    --------------------------------------------
    -- Data flow functions for building state --
    --------------------------------------------

    -- allStatesùîπ prepends to Œ± the sequence of activation steps needed to generate each CRoute in turn 
    allStatesùîπ : ‚àÄ {xs} ‚Üí All NonTrivialState xs ‚Üí ùîπ n ‚Üí ùîπ n
    allStatesùîπ []                             Œ± = Œ±
    allStatesùîπ ((ntState {p = p} _ _ _) ‚à∑ xs) Œ± = path&resetùîπ p (allStatesùîπ xs Œ±)

    stateùîπ : RMatrix ‚Üí ùîπ n ‚Üí ùîπ n
    stateùîπ X = allStatesùîπ (all-nonTrivialStates X)


    postulate stateùîπ-causal : ‚àÄ X {Œ≤} ‚Üí Causal Œ≤ ‚Üí Causal (stateùîπ X Œ≤)
{-

    -- allùîπ prepends Œ≤ with the sequence of flows needed to generate each CRoute in turn 
    allùîπ : List CRoute ‚Üí ùîπ n ‚Üí ùîπ n
    allùîπ []                        Œ≤ = Œ≤
    allùîπ (cnull              ‚à∑ xs) Œ≤ = allùîπ xs Œ≤
    allùîπ (croute _ []    _ _ ‚à∑ xs) Œ≤ = allùîπ xs Œ≤
    allùîπ (croute _ [ p ] _ _ ‚à∑ xs) Œ≤ = path&resetùîπ p (allùîπ xs Œ≤)

    allùîπ-‚âàùîπ : ‚àÄ xs Œ≤ ‚Üí Œ≤ ‚ü¶ 0 ‚üß‚âàùîπ‚ü¶ lcùïã xs ‚üß allùîπ xs Œ≤ 
    allùîπ-‚âàùîπ []                        Œ≤ t i j = ‚â°-refl
    allùîπ-‚âàùîπ (cnull              ‚à∑ xs)         = allùîπ-‚âàùîπ xs
    allùîπ-‚âàùîπ (croute _ []    _ _ ‚à∑ xs)         = allùîπ-‚âàùîπ xs
    allùîπ-‚âàùîπ (croute _ [ p ] _ _ ‚à∑ xs)         = ‚âàùîπ-appTrans (path&resetùîπ p) (allùîπ xs) (1 + length p) (lcùïã xs) (path&resetùîπ-‚âàùîπ p) (allùîπ-‚âàùîπ xs)

    allùîπ-causal : ‚àÄ xs {Œ≤} ‚Üí Causal Œ≤ ‚Üí Causal (allùîπ xs Œ≤)
    allùîπ-causal []                        {Œ≤} causal = causal
    allùîπ-causal (cnull              ‚à∑ xs) {Œ≤} causal = allùîπ-causal xs causal
    allùîπ-causal (croute _ []    _ _ ‚à∑ xs) {Œ≤} causal = allùîπ-causal xs causal
    allùîπ-causal (croute _ [ p ] _ _ ‚à∑ xs) {Œ≤} causal = path&resetùîπ-causal p (allùîπ-causal xs causal)

    allùîπ-dynamic : ‚àÄ xs {Œ≤} ‚Üí Dynamic Œ≤ ‚Üí Dynamic (allùîπ xs Œ≤)
    allùîπ-dynamic []                        dyn = dyn
    allùîπ-dynamic (cnull              ‚à∑ xs) dyn = allùîπ-dynamic xs dyn
    allùîπ-dynamic (croute _ []    _ _ ‚à∑ xs) dyn = allùîπ-dynamic xs dyn
    allùîπ-dynamic (croute _ [ p ] _ _ ‚à∑ xs) dyn = {!!} --path&resetùîπ-dynamic p (allùîπ-dynamic xs dynamic)
-}


    -----------------------------------------------
    -- Data flow functions for building messages --
    -----------------------------------------------

    allMessagesùîπ : ‚àÄ {xs} ‚Üí All NonTrivialMessage xs ‚Üí ùîπ n ‚Üí ùîπ n
    allMessagesùîπ []                             Œ± = Œ±
    allMessagesùîπ ((ntMessage {p = p} _ _) ‚à∑ xs) Œ± = path&resetùîπ p (allMessagesùîπ xs Œ±)

    messagesùîπ : ‚àÄ {Œ≤ t‚Çõ} ‚Üí Dynamic Œ≤ ‚Üí Snapshot Œ≤ t‚Çõ ‚Üí ùîπ n ‚Üí ùîπ n
    messagesùîπ dyn sn = allMessagesùîπ (all-nonTrivialMessages dyn sn)

    postulate messagesùîπ-causal : ‚àÄ {Œ≤ t‚Çõ} dyn (sn : Snapshot Œ≤ t‚Çõ) ‚Üí ‚àÄ {Œ≤‚ÇÇ} ‚Üí Causal Œ≤‚ÇÇ ‚Üí Causal (messagesùîπ dyn sn Œ≤‚ÇÇ)
    
    ------------------------------
    -- Final data flow function --
    ------------------------------

    -- finalùîπ prepends Œ≤ with the sequence of flows needed to generate the provided state and messages in flight
    finalùîπ : ‚àÄ (ùï§ : Schedule n) t‚Çõ ‚Üí RMatrix ‚Üí Snapshot (Œ≤ ùï§) t‚Çõ ‚Üí ùîπ n
    finalùîπ ùï§ t‚Çõ X sn t i j with cmp t (buildùïãùî∏ X (dynamic ùï§) sn) | Œ≤ ùï§ (t ‚à∏ buildùïãùî∏ X (dynamic ùï§) sn + t‚Çõ) i j ‚â§? t‚Çõ
    ... | tri< _ _ _ | _        = stateùîπ X (messagesùîπ (dynamic ùï§) sn (Œ≤ ùï§)) t i j
    ... | tri‚âà _ _ _ | _        = indexState X i j
    ... | tri> _ _ _ | no  _    = Œ≤ ùï§ (t ‚à∏ buildùïãùî∏ X (dynamic ùï§) sn + t‚Çõ) i j  ‚à∏ t‚Çõ + buildùïãùî∏ X (dynamic ùï§) sn
    ... | tri> _ _ _ | yes Œ≤‚â§t‚Çõ = indexMessage X (dynamic ùï§) sn i j (t ‚à∏ buildùïãùî∏ X (dynamic ùï§) sn + t‚Çõ) (n‚â§m+n (t ‚à∏ buildùïãùî∏ X (dynamic ùï§) sn) t‚Çõ) Œ≤‚â§t‚Çõ

    finalùîπ-‚âàùîπ : ‚àÄ ùï§ t‚Çõ X (sn : Snapshot (Œ≤ ùï§) t‚Çõ) ‚Üí Œ≤ ùï§ ‚ü¶ t‚Çõ ‚üß‚âàùîπ‚ü¶ buildùïãùî∏ X (dynamic ùï§) sn ‚üß finalùîπ ùï§ t‚Çõ X sn  
    finalùîπ-‚âàùîπ ùï§ t‚Çõ X sn t i j with cmp (suc t + buildùïãùî∏ X (dynamic ùï§) sn) (buildùïãùî∏ X (dynamic ùï§) sn) | Œ≤ ùï§ (suc t + buildùïãùî∏ X (dynamic ùï§) sn ‚à∏ buildùïãùî∏ X (dynamic ùï§) sn + t‚Çõ) i j ‚â§? t‚Çõ
    ... | tri< _ _ bùïã‚âÆ1+t+bùïã | _        = contradiction (s‚â§s (n‚â§m+n t (buildùïãùî∏ X (dynamic ùï§) sn))) bùïã‚âÆ1+t+bùïã
    ... | tri‚âà _ _ bùïã‚âÆ1+t+bùïã | _        = contradiction (s‚â§s (n‚â§m+n t (buildùïãùî∏ X (dynamic ùï§) sn))) bùïã‚âÆ1+t+bùïã
    ... | tri> _ _ _          | no  _    = ‚â°-sym (‚â°-trans (m+n‚à∏n‚â°m _ (buildùïãùî∏ X (dynamic ùï§) sn)) (cong (Œª t ‚Üí Œ≤ ùï§ (t + t‚Çõ) i j ‚à∏ t‚Çõ) (m+n‚à∏n‚â°m (suc t) (buildùïãùî∏ X (dynamic ùï§) sn))))
    ... | tri> _ _ _          | yes Œ≤‚â§t‚Çõ = ‚â°-trans 
                                            (m‚â§n‚áím‚à∏n‚â°0 (subst (Œª t ‚Üí Œ≤ ùï§ (t + t‚Çõ) i j ‚â§ t‚Çõ) (m+n‚à∏n‚â°m (suc t) (buildùïãùî∏ X (dynamic ùï§) sn)) Œ≤‚â§t‚Çõ)) 
                                            (‚â°-sym (m‚â§n‚áím‚à∏n‚â°0 (‚â§-trans (<‚áí‚â§ (indexMessage<buildùïã X (dynamic ùï§) sn i j _ _ Œ≤‚â§t‚Çõ)) (‚â§-reflexive (cong (Œª f ‚Üí f X (dynamic ùï§) sn) buildùïãùî∏-‚â°))))) -- REPLACE when ùî∏ gone

    finalùîπ-causal : ‚àÄ ùï§ t‚Çõ X (sn : Snapshot (Œ≤ ùï§) t‚Çõ) ‚Üí Causal (finalùîπ ùï§ t‚Çõ X sn)
    finalùîπ-causal ùï§ t‚Çõ X sn t i j with cmp (suc t) (buildùïãùî∏ X (dynamic ùï§) sn) | Œ≤ ùï§ (suc t ‚à∏ buildùïãùî∏ X (dynamic ùï§) sn + t‚Çõ) i j ‚â§? t‚Çõ
    ... | tri< 1+t<bùïã _ _ | _        = stateùîπ-causal X (messagesùîπ-causal (dynamic ùï§) sn (causal ùï§)) t i j
    ... | tri‚âà _ 1+t‚â°bùïã _ | _        = ‚â§-trans (indexState<buildùïã X (dynamic ùï§) sn i j) (‚â§-reflexive (‚â°-trans (cong (Œª f ‚Üí f X (dynamic ùï§) sn) buildùïãùî∏-‚â°) (‚â°-sym 1+t‚â°bùïã)))  -- REPLACE when ùî∏ gone
    ... | tri> _ _ bùïã<1+t | yes Œ≤‚â§t‚Çõ = ‚â§-trans (indexMessage<buildùïã X (dynamic ùï§) sn i j _ _ _) (‚â§-trans (‚â§-step (‚â§-reflexive (cong (Œª f ‚Üí f X (dynamic ùï§) sn) buildùïãùî∏-‚â°))) bùïã<1+t) -- REPLACE when ùî∏ gone
    ... | tri> _ _ bùïã<1+t | no Œ≤‚â∞t‚Çõ   = 
      begin
        suc (Œ≤ ùï§ (suc t ‚à∏ bùïã + t‚Çõ) i j ‚à∏ t‚Çõ) + bùïã    ‚â°‚ü® cong (_+ bùïã) (‚â°-sym (+-‚à∏-assoc 1 (‚â∞‚áí‚â• Œ≤‚â∞t‚Çõ))) ‚ü©
        suc (Œ≤ ùï§ (suc t ‚à∏ bùïã + t‚Çõ) i j) ‚à∏ t‚Çõ + bùïã    ‚â°‚ü® cong (Œª t ‚Üí suc (Œ≤ ùï§ (t + t‚Çõ) i j) ‚à∏ t‚Çõ + bùïã) (+-‚à∏-assoc 1 (‚â§-pred bùïã<1+t)) ‚ü©
        suc (Œ≤ ùï§ (suc (t ‚à∏ bùïã + t‚Çõ)) i j) ‚à∏ t‚Çõ + bùïã  ‚â§‚ü® _+-mono_ (‚à∏-mono (causal ùï§ (t ‚à∏ bùïã + t‚Çõ) i j) (‚â§-refl {t‚Çõ})) (‚â§-refl {bùïã}) ‚ü©
        suc (t ‚à∏ bùïã) + t‚Çõ ‚à∏ t‚Çõ + bùïã                  ‚â°‚ü® cong (_+ bùïã) (m+n‚à∏n‚â°m (suc (t ‚à∏ bùïã)) t‚Çõ) ‚ü©
        suc (t ‚à∏ bùïã) + bùïã                           ‚â°‚ü® cong (_+ bùïã) (‚â°-sym (+-‚à∏-assoc 1 (‚â§-pred bùïã<1+t))) ‚ü©
        suc t ‚à∏ bùïã + bùïã                             ‚â°‚ü® m‚à∏n+n‚â°m (<‚áí‚â§ bùïã<1+t) ‚ü©
        suc t
      ‚àé
      where 
      bùïã = buildùïãùî∏ X (dynamic ùï§) sn
      open ‚â§-Reasoning

    postulate finalùîπ-dynamic : ‚àÄ ùï§ t‚Çõ X (sn : Snapshot (Œ≤ ùï§) t‚Çõ) ‚Üí Dynamic (finalùîπ ùï§ t‚Çõ X sn)
    --finalùîπ
