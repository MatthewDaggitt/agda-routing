open import Level using () renaming (zero to lzero)
open import Data.Nat using (ℕ; zero; suc; s≤s; _<_; _≤_; _∸_; _≟_; _⊔_; _+_)
open import Data.Nat.Properties using (1+n≰n; ≤-refl; ≤+≢⇒<; <⇒≤)
open import Data.Fin using (Fin)
open import Data.Fin.Properties using ()
open import Data.Fin.Subset using (Subset; _∈_; ⊤)
open import Data.Fin.Dec using (_∈?_)
open import Data.Fin.Subset.Properties using (∈⊤)
open import Data.List using (foldr; tabulate; applyDownFrom)
open import Data.Product using (∃; _×_; _,_)
open import Relation.Binary.PropositionalEquality using (_≡_; _≢_; refl; sym; trans; subst)
open import Relation.Nullary using (yes; no)
open import Relation.Nullary.Negation using (contradiction)
open import Induction.WellFounded using (Acc; acc)
open import Induction.Nat using () renaming (<-well-founded to <-wf)

open import RoutingLib.Asynchronous.Schedule using (Schedule; 𝕋; 𝔸; 𝔹; Dynamic; StarvationFree; Causal)
open import RoutingLib.Data.Nat.Properties using (m<n≤o⇒o∸n<o∸m)
open import RoutingLib.Data.List using (max)

module RoutingLib.Asynchronous.Schedule.Times {n} where

    -----------------
    -- Activations --
    -----------------

    module ActivationTimes {α : 𝔸 n} (sf : StarvationFree α) where

      nextActivation' : ∀ {t t' i} → Acc _<_ (t' ∸ t) → t < t' → i ∈ α t' → ℕ
      nextActivation' {t} {t'} {i} (acc t'∸t-acc) t<t' i∈αₜ' with i ∈? α (suc t) | (suc t) ≟ t'
      ... | yes i∈αₜ₊₁ | _          = suc t
      ... | no  i∉αₜ₊₁ | yes t+1≡t' = contradiction (subst (λ t → i ∈ α t) (sym t+1≡t') i∈αₜ') i∉αₜ₊₁
      ... | no  i∉αₜ₊₁ | no  t+1≢t' = nextActivation' (t'∸t-acc (t' ∸ suc t) (m<n≤o⇒o∸n<o∸m ≤-refl t<t')) (≤+≢⇒< t<t' t+1≢t') i∈αₜ'

      -- Returns the next time processor i is active after time t
      nextActivation : 𝕋 → Fin n → 𝕋
      nextActivation t i with sf t i
      ... | (t' , t<t' , i∈αₜ') = nextActivation' (<-wf (t' ∸ t)) t<t' i∈αₜ'
    
      -- Returns the first time such that all processors have activated after time t
      nextTotalActivation : 𝕋 → 𝕋
      nextTotalActivation t = max (suc t) (tabulate (nextActivation t))

      -- Given that a processor has been active before, returns the most recent activation since time t
      previousActivation : ∀ {t p i} → p ≤ t → i ∈ α p → 𝕋
      previousActivation {t} {p} {i} _   _    with i ∈? α t | p ≟ t
      previousActivation {t} {_} {_} _   _    | yes _  | _       =  t
      previousActivation {t} {_} {_} _   _    | _      | yes refl = t
      previousActivation {_} {_} {i} p≤t i∈αₚ | no i∉αₜ | no p≢t with ≤+≢⇒< p≤t p≢t
      ... | s≤s p≤t₂ = previousActivation p≤t₂ i∈αₚ

    ---------------
    -- Data flow --
    ---------------

    module DataFlowTimes {β : 𝔹 n} (dyn : Dynamic β) where

      -- The first time such that data generated by j at time tᵍ is not used again by i before time t
      pointExpiryᵢⱼ≤t : 𝕋 → 𝕋 → Fin n → Fin n → 𝕋
      pointExpiryᵢⱼ≤t tᵍ zero     i j = tᵍ
      pointExpiryᵢⱼ≤t tᵍ (suc t) i j with β t i j ≟ tᵍ
      ... | yes _ = suc t
      ... | no  _ = pointExpiryᵢⱼ≤t tᵍ t i j

      -- The first time such that data generated by j at time tᵍ is not used again by i
      pointExpiryᵢⱼ : 𝕋 → Fin n → Fin n → 𝕋
      pointExpiryᵢⱼ tᵍ i j with dyn tᵍ i j
      ... | (tᶠ , tᶠ-exp) = pointExpiryᵢⱼ≤t tᵍ (suc tᶠ) i j

      -- The first time such that i only ever uses data generated by j after time t 
      expiryᵢⱼ : 𝕋 → Fin n → Fin n → 𝕋
      expiryᵢⱼ t i j = max t (applyDownFrom (λ t → pointExpiryᵢⱼ t i j) (suc t))

      -- The first time such that i only ever uses data generated after time t
      expiryᵢ : 𝕋 → Fin n → 𝕋
      expiryᵢ t i = max t (tabulate (expiryᵢⱼ t i))

      -- The first time such that all processors only ever use data generated after time t
      expiry : 𝕋 → 𝕋
      expiry t = max t (tabulate (expiryᵢ t))


    --------------------
    -- Schedule times --
    --------------------

    module ScheduleTimes (𝕤 : Schedule n) where
      
      open Schedule 𝕤
      open ActivationTimes starvationFree
      open DataFlowTimes dynamic

      -- Time at which n complete "synchronous" iterations have occurred
      syncIter : ℕ → 𝕋
      syncIter zero    = zero
      syncIter (suc n) = nextTotalActivation (expiry (syncIter n))

      -- An abstract version of syncIter that can be used to increase performance
      abstract

        syncIter𝔸 : ℕ → 𝕋
        syncIter𝔸 = syncIter

        syncIter𝔸-equiv : syncIter𝔸 ≡ syncIter
        syncIter𝔸-equiv = refl



      -- pseudoperiodᵢ

      pseudoperiodᵢ : 𝕋 → Fin n → 𝕋
      pseudoperiodᵢ t i = nextActivation (expiryᵢ t i) i      

      -- pseudoperiod

      pseudoperiod : ℕ → 𝕋
      pseudoperiod zero = zero
      pseudoperiod (suc n) = foldr _⊔_ (suc (pseudoperiod n)) (tabulate (pseudoperiodᵢ (pseudoperiod n)))

      -- An abstract version of pseudoperiod that can be used to increase performance
      abstract

        pseudoperiod𝔸 : ℕ → 𝕋
        pseudoperiod𝔸 = pseudoperiod

        pseudoperiod𝔸-≡ : pseudoperiod𝔸 ≡ pseudoperiod
        pseudoperiod𝔸-≡ = refl

    open DataFlowTimes public
    open ActivationTimes public
    open ScheduleTimes public
