open import Level using () renaming (zero to lzero)
open import Data.Nat using (â„•; zero; suc; sâ‰¤s; _<_; _â‰¤_; _âˆ¸_; _â‰Ÿ_; _âŠ”_; _+_)
open import Data.Nat.Properties using (1+nâ‰°n; â‰¤-refl; â‰¤+â‰¢â‡’<; <â‡’â‰¤; +-suc; +-identityÊ³)
open import Data.Fin using (Fin; toâ„•)
open import Data.Fin.Properties using ()
open import Data.Fin.Subset using (Subset; _âˆˆ_; âŠ¤)
open import Data.Fin.Dec using (_âˆˆ?_)
open import Data.Fin.Subset.Properties using (âˆˆâŠ¤)
open import Data.List using (foldr; tabulate; applyDownFrom)
open import Data.Product using (âˆƒ; _Ã—_; _,_; projâ‚)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; _â‰¢_; refl; sym; trans; subst; cong)
open import Relation.Nullary using (yes; no)
open import Relation.Nullary.Negation using (contradiction)
open import Induction.WellFounded using (Acc; acc)
open import Induction.Nat using () renaming (<-well-founded to <-wf)

open import RoutingLib.Asynchronous.Schedule using (Schedule; ð•‹)
open import RoutingLib.Data.Nat.Properties using (m<nâ‰¤oâ‡’oâˆ¸n<oâˆ¸m)
open import RoutingLib.Data.Table using (max)

module RoutingLib.Asynchronous.Schedule.Times {n}(ð•¤ : Schedule n) where

    open Schedule ð•¤

    âˆˆ-Î±-comm : âˆ€ t k i â†’ i âˆˆ Î± (t + suc k) â†’ i âˆˆ Î± (suc t + k)
    âˆˆ-Î±-comm t k i p = subst (i âˆˆ_) (cong Î± (+-suc t k)) p

    -----------------
    -- Activations --
    -----------------

    -- nextActive' returns t+k given that i is accessed at time t+k
    nextActive' : (t k : ð•‹)(i : Fin n) â†’ i âˆˆ Î± (t + suc k)
                  â†’ Acc _<_ k â†’ âˆƒ Î» x â†’ i âˆˆ Î± x
    nextActive' t zero    i p  _       = suc t ,
                subst (i âˆˆ_) (cong Î± (trans (+-suc t 0) (cong suc (+-identityÊ³ t)))) p
    nextActive' t (suc k) i p (acc rs) with i âˆˆ? Î± t
    ... | yes iâˆˆÎ± = t , iâˆˆÎ±
    ... | no  iâˆ‰Î± = nextActive' (suc t) k i (âˆˆ-Î±-comm t (suc k) i p)
        (rs k â‰¤-refl)

    -- nextActive returns a time after t, t', such that i is accessed at t'
    nextActive : ð•‹ â†’ Fin n â†’ ð•‹
    nextActive t i with (nonstarvation t i)
    ... | (k , p) = projâ‚ (nextActive' t k i p (<-wf k))


    ---------------
    -- Data flow --
    ---------------

    -- expiryáµ¢â±¼ returns a time such that i only uses data from j after time t
    expiryáµ¢â±¼ : ð•‹ â†’ Fin n â†’ Fin n â†’ ð•‹
    expiryáµ¢â±¼ t i j = max {suc t} 0 (Î» x â†’ (toâ„• x) + projâ‚ (finite (toâ„• x) i j))

    -- expiryáµ¢ returns a time â‰¥ t such that i only ever uses data from after time t
    expiryáµ¢ : ð•‹ â†’ Fin n â†’ ð•‹
    expiryáµ¢ t i = max t (expiryáµ¢â±¼ t i)

    -- expiry returns a time â‰¥ t such that all nodes only ever uses data from after time t
    expiry : ð•‹ â†’ ð•‹
    expiry t = max t (expiryáµ¢ t)

    
    ---------------
    -- Pseudo-Cycles --
    ---------------
    
    -- Definition of Ï†
    Ï† : ð•‹ â†’ ð•‹
    Ï† zero    = zero
    Ï† (suc t) = suc (expiry (max {n} (Ï† t) (nextActive (Ï† t))))
    
    -- Definition of Ï„
    Ï„ : ð•‹ â†’ Fin n â†’ ð•‹
    Ï„ zero    i = zero
    Ï„ (suc t) i = nextActive (Ï† (suc t)) i

{-
    module ActivationTimes {Î± : ð”¸ n} (sf : StarvationFree Î±) where

      nextActivation' : âˆ€ {t t' i} â†’ Acc _<_ (t' âˆ¸ t) â†’ t < t' â†’ i âˆˆ Î± t' â†’ â„•
      nextActivation' {t} {t'} {i} (acc t'âˆ¸t-acc) t<t' iâˆˆÎ±â‚œ' with i âˆˆ? Î± (suc t) | (suc t) â‰Ÿ t'
      ... | yes iâˆˆÎ±â‚œâ‚Šâ‚ | _          = suc t
      ... | no  iâˆ‰Î±â‚œâ‚Šâ‚ | yes t+1â‰¡t' = contradiction (subst (Î» t â†’ i âˆˆ Î± t) (sym t+1â‰¡t') iâˆˆÎ±â‚œ') iâˆ‰Î±â‚œâ‚Šâ‚
      ... | no  iâˆ‰Î±â‚œâ‚Šâ‚ | no  t+1â‰¢t' = nextActivation' (t'âˆ¸t-acc (t' âˆ¸ suc t) (m<nâ‰¤oâ‡’oâˆ¸n<oâˆ¸m â‰¤-refl t<t')) (â‰¤+â‰¢â‡’< t<t' t+1â‰¢t') iâˆˆÎ±â‚œ'

      -- Returns the next time processor i is active after time t
      nextActivation : ð•‹ â†’ Fin n â†’ ð•‹
      nextActivation t i with sf t i
      ... | (t' , t<t' , iâˆˆÎ±â‚œ') = nextActivation' (<-wf (t' âˆ¸ t)) t<t' iâˆˆÎ±â‚œ'
    
      -- Returns the first time such that all processors have activated after time t
      nextTotalActivation : ð•‹ â†’ ð•‹
      nextTotalActivation t = max (suc t) (tabulate (nextActivation t))

      -- Given that a processor has been active before, returns the most recent activation since time t
      previousActivation : âˆ€ {t p i} â†’ p â‰¤ t â†’ i âˆˆ Î± p â†’ ð•‹
      previousActivation {t} {p} {i} _   _    with i âˆˆ? Î± t | p â‰Ÿ t
      previousActivation {t} {_} {_} _   _    | yes _  | _       =  t
      previousActivation {t} {_} {_} _   _    | _      | yes refl = t
      previousActivation {_} {_} {i} pâ‰¤t iâˆˆÎ±â‚š | no iâˆ‰Î±â‚œ | no pâ‰¢t with â‰¤+â‰¢â‡’< pâ‰¤t pâ‰¢t
      ... | sâ‰¤s pâ‰¤tâ‚‚ = previousActivation pâ‰¤tâ‚‚ iâˆˆÎ±â‚š

    ---------------
    -- Data flow --
    ---------------

    module DataFlowTimes {Î² : ð”¹ n} (dyn : Dynamic Î²) where

      -- The first time such that data generated by j at time táµ is not used again by i before time t
      pointExpiryáµ¢â±¼â‰¤t : ð•‹ â†’ ð•‹ â†’ Fin n â†’ Fin n â†’ ð•‹
      pointExpiryáµ¢â±¼â‰¤t táµ zero     i j = táµ
      pointExpiryáµ¢â±¼â‰¤t táµ (suc t) i j with Î² t i j â‰Ÿ táµ
      ... | yes _ = suc t
      ... | no  _ = pointExpiryáµ¢â±¼â‰¤t táµ t i j

      -- The first time such that data generated by j at time táµ is not used again by i
      pointExpiryáµ¢â±¼ : ð•‹ â†’ Fin n â†’ Fin n â†’ ð•‹
      pointExpiryáµ¢â±¼ táµ i j with dyn táµ i j
      ... | (tá¶  , tá¶ -exp) = pointExpiryáµ¢â±¼â‰¤t táµ (suc tá¶ ) i j

      -- The first time such that i only ever uses data generated by j after time t 
      expiryáµ¢â±¼ : ð•‹ â†’ Fin n â†’ Fin n â†’ ð•‹
      expiryáµ¢â±¼ t i j = max t (applyDownFrom (Î» t â†’ pointExpiryáµ¢â±¼ t i j) (suc t))

      -- The first time such that i only ever uses data generated after time t
      expiryáµ¢ : ð•‹ â†’ Fin n â†’ ð•‹
      expiryáµ¢ t i = max t (tabulate (expiryáµ¢â±¼ t i))

      -- The first time such that all processors only ever use data generated after time t
      expiry : ð•‹ â†’ ð•‹
      expiry t = max t (tabulate (expiryáµ¢ t))

-}
    --------------------
    -- Schedule times --
    --------------------
{-
    module ScheduleTimes (ð•¤ : Schedule n) where
      
      open Schedule ð•¤
      open ActivationTimes nonstarvation
      open DataFlowTimes finite

      -- Time at which n complete "synchronous" iterations have occurred
      syncIter : â„• â†’ ð•‹
      syncIter zero    = zero
      syncIter (suc n) = nextTotalActivation (expiry (syncIter n))

      -- An abstract version of syncIter that can be used to increase performance
      abstract

        syncIterð”¸ : â„• â†’ ð•‹
        syncIterð”¸ = syncIter

        syncIterð”¸-equiv : syncIterð”¸ â‰¡ syncIter
        syncIterð”¸-equiv = refl



      -- pseudoperiodáµ¢

      pseudoperiodáµ¢ : ð•‹ â†’ Fin n â†’ ð•‹
      pseudoperiodáµ¢ t i = nextActivation (expiryáµ¢ t i) i      

      -- pseudoperiod

      pseudoperiod : â„• â†’ ð•‹
      pseudoperiod zero = zero
      pseudoperiod (suc n) = foldr _âŠ”_ (suc (pseudoperiod n)) (tabulate (pseudoperiodáµ¢ (pseudoperiod n)))

      -- An abstract version of pseudoperiod that can be used to increase performance
      abstract

        pseudoperiodð”¸ : â„• â†’ ð•‹
        pseudoperiodð”¸ = pseudoperiod

        pseudoperiodð”¸-â‰¡ : pseudoperiodð”¸ â‰¡ pseudoperiod
        pseudoperiodð”¸-â‰¡ = refl

    open DataFlowTimes public
    open ActivationTimes public
    open ScheduleTimes public
-}
