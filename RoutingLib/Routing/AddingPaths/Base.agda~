open import Level using (_⊔_)
open import Data.Nat using (ℕ; suc) renaming (_≤_ to _≤ℕ_)
open import Relation.Nullary using (¬_; yes; no)
open import Data.Product using (_×_; _,_)
open import Data.Fin using (Fin)
open import Data.Fin.Properties using () renaming (_≟_ to _≟ᶠ_)
open import Data.Maybe using (just; nothing)
open import Relation.Nullary.Negation using (contradiction)
open import Relation.Binary
open import Relation.Binary.PropositionalEquality using (_≡_; subst) renaming (refl to ≡-refl; sym to ≡-sym; trans to ≡-trans)
open import Algebra.FunctionProperties using (Op₂)

open import RoutingLib.Algebra.FunctionProperties using (_Preserves_; _Preservesₗ_; Selective)
open import RoutingLib.Routing.Definitions
open import RoutingLib.Data.Graph using (Graph; _ᵉ∈ᵍ?_)
open import RoutingLib.Data.Graph.EGPath renaming (weight to weight′)
open import RoutingLib.Data.Graph.EGPath.Properties
open import RoutingLib.Relation.Binary.RespectedBy using (_RespectedBy_; Respects₂⇨RespectedBy)



module RoutingLib.Routing.AddingPaths.Base 
  {a b ℓ} (ra : RoutingAlgebra a b ℓ) 
  (⊕-sel : Selective (RoutingAlgebra._≈_ ra) (RoutingAlgebra._⊕_ ra))
  (one : (RoutingAlgebra.Route ra))
  {n-1 : ℕ}
  (G : Graph (RoutingAlgebra.Step ra) (suc n-1))
  where


  open RoutingAlgebra ra public

  n : ℕ
  n = suc n-1


  -- Steps

  open import RoutingLib.Algebra.AddingElements (Fin n × Fin n × Step) using () renaming (Aₑ to PStep; val to edge; e to none) public


  -- Selection

  open import RoutingLib.Algebra.Selectivity.Properties _≈_ _⊕_ ⊕-sel using (selection; sel₁; sel₂; sel≈; SelCase)
  
  select : ∀ x y → SelCase x y
  select = selection sym trans _≟_


  -- Combined length-lexicographic ordering

  open import RoutingLib.Relation.Binary.PreorderLex (_≤ₗ_ {G = G}) _≤ₚ_ 
    using (×-isDecTotalOrder) 
    renaming (×-Lex to _≤ₗₚ_) 
    public

  open IsDecTotalOrder (×-isDecTotalOrder ≤ₗ-isDecTotalPreorder ≤ₚ-isDecTotalOrder) using () renaming (
      refl to ≤ₗₚ-refl;
      trans to ≤ₗₚ-trans;
      antisym to ≤ₗₚ-antisym;
      total to ≤ₗₚ-total; 
      _≤?_ to _≤ₗₚ?_;
      ≤-resp-≈ to ≤ₗₚ-resp₂-≈
    ) public

  ≤ₗₚ-resp-≈ₚ : _≤ₗₚ_ RespectedBy _≈ₚ_
  ≤ₗₚ-resp-≈ₚ = Respects₂⇨RespectedBy ≤ₗₚ-resp₂-≈
